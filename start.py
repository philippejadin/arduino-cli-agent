#!/usr/bin/env python3

# this got me started quick https://stackoverflow.com/questions/33662842/simple-python-server-to-process-get-and-post-requests-with-json

from bottle import WSGIRefServer, route, run, template, request, post, get, static_file, response
import subprocess
import sys
import os
import json
import guizero
import threading


DEBUG = True


# a few utility functions first

# logs if debug is enabled
def log(s):
    if DEBUG:
        print (s)
        print('-------------------')
        #if console:
        console.append('-------------------------')
        console.append(s)

# returns a json formated error message
def error(message):
    response.status = 400
    response.content_type = 'application/json'
    return {'error' : True, 'message' : message}

# returns a json formated success message
def success(message):
    response.status = 200
    response.content_type = 'application/json'
    return {'error' : False, 'message' : message}

# call the arduino-cli binary and return the process
def arduino_cli(command_line):
    return subprocess.run(['./arduino-cli'] + command_line,stderr=subprocess.STDOUT, stdout=subprocess.PIPE, cwd=os.path.dirname(os.path.abspath(__file__)))

# server class to allow shutdown of bottle server, see https://stackoverflow.com/questions/11282218/bottle-web-framework-how-to-stop
class MyServer(WSGIRefServer):
    def run(self, app): # pragma: no cover
        from wsgiref.simple_server import WSGIRequestHandler, WSGIServer
        from wsgiref.simple_server import make_server
        import socket

        class FixedHandler(WSGIRequestHandler):
            def address_string(self): # Prevent reverse DNS lookups please.
                return self.client_address[0]
            def log_request(*args, **kw):
                if not self.quiet:
                    return WSGIRequestHandler.log_request(*args, **kw)

        handler_cls = self.options.get('handler_class', FixedHandler)
        server_cls  = self.options.get('server_class', WSGIServer)

        if ':' in self.host: # Fix wsgiref for IPv6 addresses.
            if getattr(server_cls, 'address_family') == socket.AF_INET:
                class server_cls(server_cls):
                    address_family = socket.AF_INET6

        srv = make_server(self.host, self.port, app, server_cls, handler_cls)
        self.srv = srv ### THIS IS THE ONLY CHANGE TO THE ORIGINAL CLASS METHOD!
        srv.serve_forever()

    def shutdown(self): ### ADD SHUTDOWN METHOD.
        self.srv.shutdown()
        # self.server.server_close()

@route('/')
def index():
    return static_file('index.html', './examples/')

@route('/hello/<name>')
def index(name):
    return template('<b>Hello {{name}}</b>!', name=name)

@route('/error')
def index():
    return error("This is an error message")

@route('/check')
def index():
    tmp = arduino_cli(['version'])
    log (tmp)
    return tmp.stdout.decode().replace('\n', '<br />')

@route('/compile')
def index():
    return static_file('uploader.html', './examples/')

@post('/compile')
def index():
    if not request.forms.get('arduino_code') or not request.forms.get('fqbn') or not request.forms.get('filename'):
        return error('Please provide the arduino_code, fqbn and filename fields.')

    sketch_name = request.forms.get('filename')

    sketch_path =  os.getcwd() + '/sketches/' + sketch_name + '/'

    # Create the sketch directory and file
    try:
        os.makedirs (sketch_path)
    except:
        log('Error creating sketch directory at ' +  sketch_path)

    sketch_path =  os.getcwd() + '/sketches/' + sketch_name + '/'
    sketch_filename = sketch_path + sketch_name + '.ino'

    sketch_file = open(sketch_filename, 'w')
    sketch_file.write("// File autogenerated by blockly, save as a copy to avoid overwrite\n\n")
    sketch_file.write(request.forms.get('arduino_code'))
    sketch_file.close();

    # Compile the sketch :
    log(type(request.forms.get('board')))
    command_line = ["compile", "--fqbn", str(request.forms.get('fqbn')), str(sketch_path)]
    log(command_line)
    compile_process = arduino_cli(command_line)
    log (str(compile_process))

    if compile_process.returncode != 0:
        return error("Compilation failed, arduino-cli says : " + str(compile_process.stdout.decode()))

    # find a connected board. curently the first one found is used (most common use case)
    board_list_process = arduino_cli(['board', 'list', '--format', 'json'])
    if board_list_process.returncode != 0:
        return error("Find a connected board failed, arduino-cli says : " + str(board_list_process.stdout.decode()))

    # Currently we use the first detected port. Needs to be better implemented
    boards = json.loads(board_list_process.stdout)
    port = (boards['serialBoards'][0]['port'])


    upload_process = arduino_cli(['upload', '--port', port, "--fqbn", str(request.forms.get('fqbn')), str(sketch_path)])
    if upload_process.returncode != 0:
        return error("Upload failed, arduino-cli says : " + str(upload_process.stdout.decode()))


    return success('Compilation suceeded')

@get('/board/list')
def index():
    command_line = ["board", "list", "--format", "json"]
    process = arduino_cli(command_line)
    log (str(process))
    if process.returncode != 0:
        return error("Error, arduino-cli says : " + str(process.stdout.decode()))


    return (process.stdout.decode())

@get('/board/listall')
def index():
    command_line = ["board", "listall", "--format", "json"]
    process = arduino_cli(command_line)
    log (str(process))
    if process.returncode != 0:
        return error("Error, arduino-cli says : " + str(process.stdout.decode()))

    response.content_type = 'application/json'
    return (process.stdout)

@get('/core/install/<package>')
def index(package):
    command_line = ["core", "install", package]
    process = arduino_cli(command_line)
    log (str(process))
    if process.returncode != 0:
        return error("Error, arduino-cli says : " + str(process.stdout.decode()))

    response.content_type = 'application/json'
    return success(process.stdout.decode())

@get('/core/list')
def index():
    command_line = ["core", "list", "--format", "json"]
    process = arduino_cli(command_line)
    log (str(process))
    if process.returncode != 0:
        return error("Error, arduino-cli says : " + str(process.stdout.decode()))

    response.content_type = 'application/json'
    return (process.stdout.decode())

@get('/core/update-index')
def index():
    command_line = ["core", "update-index"]
    process = arduino_cli(command_line)
    log (str(process))
    if process.returncode != 0:
        return error("Error, arduino-cli says : " + str(process.stdout.decode()))

    response.content_type = 'application/json'
    return success(process.stdout.decode())



# experimental catch all
#@get('/<item>/<action>')
#def index(item, action):
#    command_line = [item, action]
#    process = arduino_cli(command_line)
#    log (str(process))
#    if process.returncode != 0:
#        return error("Error, arduino-cli says : " + str(process.stdout.decode()))
#    return (process.stdout.decode())

# warn python 3 only
if sys.version_info[0] < 3:
    raise Exception("Python 3 or a more recent version is required.")



def start_server():
    log('Starting server')
    run(server=server)


def quit():
    log('exit')
    app.destroy()
    server.shutdown()


if __name__ == '__main__':
    # start the gui
    app = guizero.App(title="Arduino Blockly Agent")
    text = guizero.Text(app, text="Console output : ")
    button = guizero.PushButton(app, command=quit, text="Quit")
    console = guizero.TextBox(app, width=40, height=10, multiline=True, scrollbar=True)

    # start the server
    server = MyServer(host="localhost", port=3280, debug=True, reloader=False)
    threading.Thread(target=start_server).start()
    app.display()
